# Java反射机制与动态代理（—）

###反射机制概述：
（1）定义：
反射机制是在运行状态中，对于任意一个类，
都能够知道这个类的所有属性和方法；对于任意一个对象，
都能够调用它的任意一个方法和属性；
这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。

 (2) 作用：
 
 - （一）在运行时判断任意一个对象所属的类；
 - （二）在运行时构造任意一个类的对象；
 - （三）在运行时判断任意一个类所具有的成员变量和方法；
 - （四）在运行时调用任意一个对象的方法；
 - （五）在运行时创建新类对象
 - （六）生成动态代理。
 
 ###我们要理解一个东西：
 在Java程序中许多对象在运行时都会出现两种类型：
`编译时类型和运行时类型`
 
 编译时的类型由声明该对象时使用的类型决定，
 
 运行时的类型由实际赋给对象的类型决定：
 
 ```java
//如：
Person p =new Student();
//编译时类型为Person，而运行时为Student
```
###静态编译和动态编译
静态编译：在编译时确定类型，绑定对象，即通过

动态编译：运行时确定类型，绑定对象。动态编译最大限度的发挥了java的灵活性，体现了多态的应用，有利于降低类之间的耦合性。

优点：可以实现动态创建对象和编译，体现出很大的灵活性。


缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求，这意味着通信，意味着又要执行多个步骤。


##设计模式之代理模式

代理模式（Proxy Pattern）定义：给某一个对象提供一个代理，并由代理对象控制原对象的引用。


1. Subject抽象主题角色。是抽象类或接口，是一个最普通的业务类型定义。游戏者接口。
2. RealSubject真实主题角色，定义了代理角色所代理的真实对象，在真实主题角色中实现了真实的业务操作，可以通过代理主题角色间接调用真实主题角色中定义的方法。
3. Proxy代理主题角色。委托类、代理类，负责对真实角色的应用，把所有抽象主题类定义的方法限制委托给真实主题角色实现，并在真实主题角色处理完毕前后做预处理和善后处理。代练者。



###适用环境
- 远程代理：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理有叫做大使
- 虚拟代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要的才会被创建
- Copy-on-Write 代理：它是虚拟代理的一种，把复制（克隆）操作延迟到只有在客户端真正需要时才执行。一般来说，对象的深度克隆是一个开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。
- 保护代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。
- 缓存代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。
- 防火墙代理：保护目标不让恶意用户接近。
- 同步化代理：使几个用户能够同时使用给一个对象而没有冲突。
- 智能引用代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来。

###总体流程：
1.  通过实现InvocationHandler接口创建自己的调用处理器 。
InvocationHandler handler = new InvocationHandlerImpl(...);

2. 通过为Proxy类指定ClassLoader对象和一组interface创建动态代理类。就是说指定代理谁。
Class clazz = Proxy.getProxyClass(classLoader,new Class[]{...});

3. 通过反射机制获取动态代理类的构造函数，其参数类型是调用处理器接口类型
Constructor constructor = clazz.getConstructor(new Class[]{InvocationHandler.class});

4. 通过构造函数创建代理类实例，此时需将调用处理器对象作为参数被传入
Interface Proxy = (Interface)constructor.newInstance(new Object[] (handler));
为了简化对象创建过程，Proxy类中的newInstance方法封装了2~4，只需两步即可完成代理对象的创建。
生成的ProxySubject继承Proxy类实现Subject接口，实现的Subject的方法实际调用处理器的invoke方法，而invoke方法利用反射调用的是被代理对象的的方法（Object result=method.invoke(proxied,args)）。
注意点：

####需要注意
- Proxy.newProxyInstance 创建的代理对象是在jvm运行时动态生成的一个对象，它并不是我们的InvocationHandler类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号。
- Java中，必须通过接口去管理动态代理。
- 对代理类的方法的调用实际上都会调用中介类(调用处理器)的invoke方法，在invoke方法中我们调用委托类的相应方法，并且可以添加自己的处理逻辑。

